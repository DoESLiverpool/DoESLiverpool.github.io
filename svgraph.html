<!DOCTYPE html>
<html>
<head>
<script src="jquery-2.1.4.min.js"></script>    
<script type="text/javascript" src="raphael.js"></script>    
<script type="text/javascript" src="raphpolygonsorting.js"></script>    
<meta charset="utf-8">
<title>Experimental SVG lattice hinge generator</title>
<script>

function exportSVG()
{
    var xs = new XMLSerializer();
    var data = document.getElementById("svg1");
    var a = document.createElement('a');
    var blob = new Blob([xs.serializeToString(data)], {'type':"image/svg+xml"});
    a.href = window.URL.createObjectURL(blob);
    a.download = "test.svg";
    a.click();
}

var bcancelExIm = false; 
function exportPLT()
{
    var lplt = [ "IN;\n", "WU0;\n" ]; 
    var samplerateunit = 0.9; 
    var fac = 40/mmpixwidth; // PLT file operates at 40units per pixel
    var ytop = 10000; 
    var i = 0; 
    bcancelExIm = false; 
    $("#readingcancel").text("exportPLT"); 
    function exportPLTpathR() {
        var path = rlist[i]; 
        var pl = path.getTotalLength(); 
        if (pl != 0.0) {
            var nsamples = Math.ceil(pl/samplerateunit); 
            var spnum = spnums[path.attr("stroke")]; 
            lplt.push("SP"+spnum+";\n"); 
            lplt.push("LT;\n"); 
            for (var j = 0; j <= nsamples; j++) {
                var p = path.getPointAtLength(pl*(j/nsamples)); 
                lplt.push((j == 0 ? "PU" : "PD")+(p.x*fac).toFixed(3)+" "+(ytop-p.y*fac).toFixed(3)+"\n"); 
            }
        }
        if (bcancelExIm) {
            return; 
        } else if (++i < rlist.length) {
            setTimeout(exportPLTpathR, 1); 
        } else {
            lplt.push("SP0;\n"); 
            var a = document.createElement('a');
            var blob = new Blob(lplt, {'type':"text/plain"});
            a.href = window.URL.createObjectURL(blob);
            a.download = "test.plt";
            a.click();
        }
        $("#readingcancel").text(i+"/"+rlist.length); 
    };
    exportPLTpathR(); 
}

var mmpixwidth, mmpixheight; // to be used to scale back to output SVG (not for version 0.43)
var spnums = { }, spcount = 0; 
function WorkOutPixelScale(txt, td) 
{
    var tsvg = $(td.children()[0]).parent(); // seems not to work directly
    var sheight = tsvg.attr("height"); 
    var swidth = tsvg.attr("width"); 
    var viewBox = []; // (seemingly unable to lift the viewBox as an attribute)
    txt.replace(/viewBox="(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)/g, 
        function(a, x, y, w, h) { 
            viewBox.push(parseFloat(x), parseFloat(y), parseFloat(w), parseFloat(h)); 
    }); 
    console.log("facts:" + sheight+"  "+swidth + "  "+viewBox); 
    var mmheight = parseFloat(sheight); 
    var mmwidth = parseFloat(swidth); 
    mmpixwidth = viewBox[2]/mmwidth; 
    mmpixheight = viewBox[3]/mmheight; 
    $("#pixscaleX").text(mmpixwidth.toFixed(3)); 
    $("#pixscaleY").text(mmpixheight.toFixed(3)); 
}

function TestCollision(dx, dy) 
{
    for (var i = 0; i < opts.length; i++) {
        var x = opts[i][0] + dx; 
        var y = opts[i][1] + dy; 
        if (y >= paper1.height*paper1scale)
            return false; 
        for (var j = 0; j < rlist.length; j++) {
            if (rlist[j] == pathselected)
                continue; 
            if (rlist[j].isPointInside(x, y))
                return false; 
        }
    }
    return true; 
}

var paper1 = null; 
var paper1scale = 1; 
var filenamelist = [ ]; 
var rlistbyfnum = [ ]; 
var rlist = [ ]; 
var pathselected = null; 
var opts; 
var collidestepout = 10, collidestepover = 10; 
var ylo, yhi; 
var perprods; 
function CollideBinary() 
{
    // paper1.getElementsByPoint(x, y); 
    var ymid = (ylo + yhi)/2; 
    if (TestCollision(0, ymid)) {
        ylo = ymid; 
        pathselected.transform("t0,"+ylo); 
    } else {
        yhi = ymid; 
    }
    if (yhi - ylo <= collidestepout + 1) {
        pathselected.attr("path", Raphael.mapPath(pathselected.attr("path"), pathselected.matrix)); 
        pathselected.transform("t0,0"); 
        perprods.remove(); 
    } else {
        setTimeout(CollideBinary, 5); 
    }
}

/* refer to: 
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
*/

function MoveCollide()
{
    path = pathselected; 
    var pl = path.getTotalLength(); 
    console.log(pl); 
    var ds = [ ]; 
    opts = [ ]; 
    for (var i = 0; i < pl; i += collidestepover) {
        var pal = path.getPointAtLength(i); 
        var angnorm = Raphael.rad(pal.alpha+90); 
        var sa = Math.sin(angnorm); 
        var ca = Math.cos(angnorm); 
        var d = collidestepout; 
        if (path.isPointInside(pal.x+ca*d, pal.y+sa*d)) { d = -d }; 
        ds.push("M", pal.x, ",", pal.y, "l", ca*d, ",", sa*d); 
        opts.push([pal.x+ca*d, pal.y+sa*d]); 
    }
    
    perprods = paper1.path(ds.join("")); 
    ylo = 0; 
    yhi = 400; 
    setTimeout(CollideBinary, 5); 
}



var Drlends, Drlidat, Djdseqs, Dcycseqs; 
function FindClosedPathSequences(rlistb, closedist)  // also take in spnums known not external
{
    // create arrays of closest links
    var closedistSq = closedist*closedist; 
    var bsamespnumconnections = true; 
    var rlends = [ ]; // [ x, y, i, bfore ]
    var rlidat = [ ]; // index*2 front back
    Drlends = rlends; 
    Drlidat = rlidat; 
    for (var i = 0; i < rlistb.length; i++) {
        var rl = rlistb[i]; 
        var pseq = rl.path.attrs.path; 
        var seg0 = pseq[0]; 
        rlends.push([ seg0[1], seg0[2], i, false ]); 
        var segE = pseq[pseq.length - 1]; 
        rlends.push([ segE[segE.length-2], segE[segE.length-1], i, true ]); 
        rlidat.push([ ], [ ]); // each will be a list of cross connections [d, j]
    } 
    rlends.sort(); 
    var rlconns = 0; 
    for (var j = 0; j < rlends.length - 1; j++) {
        var rle = rlends[j]; 
        var xB = rle[0], yB = rle[1]; 
        var jd = rle[2]*2 + (rle[3] ? 1 : 0); 
        for (var j1 = j+1; ((j1 < rlends.length) && (rlends[j1][0] <= xB + closedist)); j1++) {
            var rle1 = rlends[j1]; 
            var dx = rle1[0] - xB;
            var dy = rle1[1] - yB; 
            var dCsq = dx*dx + dy*dy; 
            if (dCsq <= closedistSq) {
                var jd1 = rle1[2]*2 + (rle1[3] ? 1 : 0); 
                if (!bsamespnumconnections || (rlistb[rle[2]].spnum == rlistb[rle1[2]].spnum)) {
                    rlidat[jd].push([dCsq, jd1]); 
                    rlidat[jd1].push([dCsq, jd]); 
                    rlconns++; 
                }
            }
        }
    }

    // sort adjacencies at endpoints by distance
    for (var j = 0; j < rlidat.length - 1; j++)  
        rlidat[j].sort(); 

    function disconnectJD1(jd, jd1) {
        var rlid1 = rlidat[jd1]; 
        //console.log("disconjd", jd, jd1, rlid1.slice()); 
        var d1i; 
        for (d1i = rlid1.length - 1; d1i >= 0; d1i--) {
            if (rlid1[d1i][1] == jd)
                break; 
        }
        for (++d1i ; d1i < rlid1.length; d1i++)
            rlid1[d1i-1] = rlid1[d1i]; 
        rlid1.pop(); 
    }
    
    // extract closed sequences of paths that join up
    var jdseqs = [ ];  
    Djdseqs = jdseqs; 
    var i = 0; 
    var Dloops = rlconns*2 + rlistb.length; 
    while (i < rlistb.length) {
        console.assert(Dloops-- >= 0); 
        if (rlidat[i*2].length == 0) {
            if (rlidat[i*2 + 1].length == 0) {
                i++; 
            } else {
                var jd = i*2 + 1; 
                while (rlidat[jd].length != 0) {
                    disconnectJD1(jd, rlidat[jd].pop()[1]); 
                }
            }
        } else if (rlidat[i*2 + 1].length == 0) {
            var jd = i*2; 
            while (rlidat[jd].length != 0) {
                disconnectJD1(jd, rlidat[jd].pop()[1]); 
            }
        } else {
            var jdseq = [ ]; 
            var jd0 = i*2 + 1; 
            var jd = jd0; 
            while (true) {
                if (rlidat[jd].length == 0) {
                    var jdl = jdseq.pop(); 
                    //console.log("removing jdl", jdl, jd0); 
                    disconnectJD1(jdl, rlidat[jdl].shift()[1]); 
                    break; 
                } else if (jdseq.length > rlistb.length - i*0) {
                    //console.log("removing jd0 semiloop", jd0); 
                    disconnectJD1(jd0, rlidat[jd0].shift()[1]); 
                    break; 
                } else {
                    jdseq.push(jd); 
                    var jd1 = rlidat[jd][0][1];
                    jd = jd1 + ((jd1%2) == 1 ? -1 : 1); 
                    if (jd == jd0) 
                        break; 
                }
            }
            if (jd == jd0) {
                //console.log("found cycle", jdseq); 
                jdseqs.push(jdseq); 
                for (var ijd = 0; ijd < jdseq.length; ijd++) {
                    var jd = jdseq[ijd]; 
                    while (rlidat[jd].length != 0) {
                        disconnectJD1(jd, rlidat[jd].pop()[1]); 
                    }
                    jd1 = jd + ((jd%2) == 1 ? -1 : 1); 
                    while (rlidat[jd1].length != 0) {
                        disconnectJD1(jd1, rlidat[jd1].pop()[1]); 
                    }
                }
                i++; 
            } 
        }
    }

    var rlcycnum = new Array(rlistb.length); 
    var cycseqs = [ ]; // [{bpaths, darea, parea}] 
    for (var j = 0; j < jdseqs.length; j++) {
        var jdseq = jdseqs[j]; 
        var bpaths = [ ]; // bpaths:[{path, spnum, d, cmatrix(, bfore)}]
        var darea = [ ]; 
        for (var ijd = 0; ijd < jdseq.length; ijd++) {
            var jd = jdseq[ijd]; 
            var i = jd/2|0; 
            var bfore = ((jd%2)==1); 
            var bpath = rlistb[i]; 
            bpath.bfore = bfore;  // new attribute
            bpaths.push(bpath); 
            var spath = bpath.path.attr("path"); 
            console.assert(spath[0][0] == "M"); 
            var px, py; 
            if (bfore) {
                if (ijd == 0) {
                    darea.push(spath[0]); 
                } else if ((px != spath[0][1]) || (py != spath[0][2])) {
                    darea.push(["L", spath[0][1], spath[0][2]]); 
                }
                dpathappendsegs(darea, spath, false); 
                var lseq = spath[spath.length-1]; 
                px = lseq[lseq.length - 2]; 
                py = lseq[lseq.length - 1]; 
            } else {
                console.assert(ijd != 0); 
                var lseq = spath[spath.length-1]; 
                if ((px != lseq[lseq.length - 2]) || (py != lseq[lseq.length - 1])) {
                    darea.push(["L", lseq[lseq.length - 2], lseq[lseq.length - 1]]); 
                }
                dpathappendsegs(darea, spath, true); 
                px = spath[0][1]; 
                py = spath[0][2]; 
            }
            console.assert(rlcycnum[i] === undefined); 
            rlcycnum[i] = j; 
        }
        console.assert(darea[0][0] == "M"); 
        if ((px != spath[0][1]) || (py != spath[0][2])) {
            darea.push(["L", darea[0][1], darea[0][2]]); 
        }
        cycseqs.push({bpaths:bpaths, darea:darea, spnum:bpaths[0].spnum, bclockorient:FindPathOrientation(darea)}); 
    }
    
    var bpathssinglets = [ ]; 
    for (var i = 0; i < rlcycnum.length; i++) {
        if (rlcycnum[i] === undefined) {
            bpathssinglets.push(rlistb[i]); 
        }
    }
    cycseqs.push(bpathssinglets); 
    
    Dcycseqs = cycseqs; 
    return cycseqs; 
}


// function FindPathSinglets(rlistb, cycseqs)
function FindAreaGroupings(rlistb, cycseqs)
{
    var nsampspercurve = 3; 
    var nsampspercurveDecider = 2; // work on contour points because using actual inner points gives false positives if mishandled
    var cycsamplepts = [ ]; 
    for (var ic = 0; ic < cycseqs.length; ic++) {
        var cycseq = cycseqs[ic]; 
        var samplepts = [ Raphael.pathBBox(cycseq.darea) ]; 
        var tl = Raphael.getTotalLength(cycseq.darea); 
        for (var i = 0; i < nsampspercurve; i++) {
            var pal = Raphael.getPointAtLength(cycseq.darea, tl*i/nsampspercurve); 
            samplepts.push(pal); 
        }
        cycsamplepts.push(samplepts); 
    }
console.log("cycsamplepts2", cycsamplepts); 

    // find insidedness
    var continnerpairs = [ ]; 
    for (var ic0 = 0; ic0 < cycseqs.length - 1; ic0++) {
        var cycseq0 = cycseqs[ic0]; 
        var cycsamplepts0 = cycsamplepts[ic0]
        for (var ic1 = ic0+1; ic1 < cycseqs.length; ic1++) {
            var cycseq1 = cycseqs[ic1]; 
            var cycsamplepts1 = cycsamplepts[ic1]
            if (Raphael.isBBoxIntersect(cycsamplepts0[0], cycsamplepts1[0])) {
                var si0 = 0, si1 = 0; 
                for (var i = 1; i <= nsampspercurve; i++) {
                    //var pt1m = [["M", cycsamplepts1[i].x, cycsamplepts1[i].y], ["H", cycsamplepts1[0].x2 + 10]]; 
                    //var pt0m = [["M", cycsamplepts0[i].x, cycsamplepts0[i].y], ["H", cycsamplepts0[0].x2 + 10]]; 
                    //var ni0 = Raphael.pathIntersectionNumber(cycseq0.darea, pt1m); 
                    //var ni1 = Raphael.pathIntersectionNumber(cycseq1.darea, pt0m); 
                    si0 += (Raphael.isPointInsidePath(cycseq0.darea, cycsamplepts1[i].x, cycsamplepts1[i].y) ? 1 : 0); 
                    si1 += (Raphael.isPointInsidePath(cycseq1.darea, cycsamplepts0[i].x, cycsamplepts0[i].y) ? 1 : 0); 
                }

                if ((si0 >= nsampspercurveDecider) && (si1 < nsampspercurveDecider))
                    continnerpairs.push([ic1, ic0]); 
                else if ((si0 < nsampspercurveDecider) && (si1 >= nsampspercurveDecider))
                    continnerpairs.push([ic0, ic1]); 
                else if ((si0 >= nsampspercurveDecider) && (si1 >= nsampspercurveDecider))
                    console.log("overlapping", ic0, ic1, "si", si0, si1); 
            }
        }
    }
    

    // containment sets
    console.log(continnerpairs); 
    var mapsdown = { }; 
    var mapsup = { }; 
    for (var ic = 0; ic < cycseqs.length; ic++) {
        mapsdown[ic] = [ ]; 
        mapsup[ic] = [ ]; 
    }
    for (var i = 0; i < continnerpairs.length; i++) {
        var ic0 = continnerpairs[i][0]; 
        var ic1 = continnerpairs[i][1]; 
        mapsdown[ic1].push(ic0); 
        mapsup[ic0].push(ic1); 
    }

    var mapsdown1 = { }; 
    for (var ic = 0; ic < cycseqs.length; ic++) {
        var md = mapsdown[ic]; 
        var md2 = [ ]; 
        for (var i = 0; i < md.length; i++) {
            var md11 = mapsdown[md[i]]; 
            for (var j = 0; j < md11.length; j++) {
                md2.push(md11[j]); 
            }
        }
        var md1 = [ ]; 
        for (var i = 0; i < md.length; i++) {
            if (!md2.includes(md[i])) {
                md1.push(md[i]); 
            }
        }
        mapsdown1[ic] = md1; 
    }
    
    
    // work down the tree
    console.log("mapsdown", mapsdown); 
    console.log("mapsdown1", mapsdown1); 
    console.log(mapsup); 
    var outerlevels = [ ]; 
    for (var ic = 0; ic < cycseqs.length; ic++) {
        if (mapsup[ic].length == 0) {
            outerlevels.push(ic); 
        }
    }
    var contislandlists = [ ]; 
    while ((outerlevels.length != 0) && (contislandlists.length < cycseqs.length + 10)) {
        var ic = outerlevels.shift(); 
        contislandlist = [ ic ]; 
        var md1 = mapsdown1[ic]; 
        for (var i = 0; i < md1.length; i++) {
            contislandlist.push(md1[i]); 
            var md1i1 = mapsdown1[md1[i]]; 
            for (var j = 0; j < md1i1.length; j++) {
                outerlevels.push(md1i1[j]); 
            }
        }
        contislandlists.push(contislandlist); 
        console.assert(contislandlists.length <= cycseqs.length); 
    }
    console.log(contislandlists); 
    return contislandlists; 
}

function CreateAreaGroupings(rlistb, cycseqs, contislandlists)
{
    var areagroups = [ ]; 
    for (var i = 0; i < contislandlists.length; i++) {
        var contislandlist = contislandlists[i]; 
        var gcyceseqs = [ ]; 
        var dgroup = [ ]; 
        var allpaths = [ ]; 
        for (var j = 0; j < contislandlist.length; j++) {
            var k = contislandlist[j]; 
            gcyceseqs.push(cycseqs[k]);
            var darea = cycseqs[k].darea; 
            if (cycseqs[k].bclockorient == (j == 0)) {
                var lseq = darea[darea.length-1]; 
                darea.push(["M", lseq[lseq.length - 2], lseq[lseq.length - 1]]); 
                dpathappendsegs(dgroup, darea, true); 
            } else {
                dgroup.push(darea[0]); 
                dpathappendsegs(dgroup, darea, false); 
            }

            var bpaths = cycseqs[k].bpaths; 
            for (var m = 0; m < bpaths.length; m++)
                allpaths.push(bpaths[m]); 
        }
        areagroups.push({gcyceseqs:gcyceseqs, dgroup:dgroup, allpaths:allpaths}); 
    }
    return areagroups; 
}

function SingletsToGroupings(areagroups, bpathssinglets)
{
    var lamchecks = [ 0.5, 0.1, 0.9, 0.7, 0.33233432 ]; 
    for (var i = 0; i < bpathssinglets.length; i++) {
        var bpath = bpathssinglets[i]; 
        var tl = bpath.path.getTotalLength(); 
        var il = 0; 
        var Jb = -1; 
        while (il < lamchecks.length) {
            var pt = bpath.path.getPointAtLength(tl*lamchecks[il]); 
            var Js = [ ]; 
            for (var j = 0; j < areagroups.length; j++) {
                if (Raphael.isPointInsidePath(areagroups[j].dgroup, pt.x, pt.y))
                    Js.push(j); 
            }
            if (Js.length == 1) {
                Jb = Js[0]; 
                break; 
            }
            if (Js.length != 0)
                Jb = Js[0]; 
            il++; 
        }
        if (Jb != -1) 
            areagroups[Jb].allpaths.push(bpath); 
    }
}

function ProcessToPathGroupings(rlistb, closedist)
{
    // extract the spnums
    var mspnums = { }; 
    for (var i = 0; i < rlistb.length; i++) {
        mspnums[rlistb[i].spnum] = 1; 
    }
    var spnums = Object.keys(mspnums); 
    
    // form the closed path sequences per spnum
    var spnumscp = spnums;  // this filters out the paths considered for forming cycles by colour
    var jdseqs = [ ];  // indexes dlist
    for (var ispnum = 0; ispnum < spnumscp.length; ispnum++) {
        var spnum = spnumscp[ispnum]; 
        $("#readingcancel").text("joining spnum="+spnum); 
        var dlist = [ ]; 
        var npathsc = 0; 
        for (var i = 0; i < rlistb.length; i++) {
            dlist.push(rlistb[i].spnum == spnum ? rlistb[i].path.attrs.path : null); 
            npathsc++; 
        }
        var ljdseqs = FindClosedPathSequencesD(dlist, closedist); 
        var npathsleft = 0; 
        for (var i = 0; i < ljdseqs.length; i++)
            npathsleft += ljdseqs[i].length; 
        //console.log("ljdseqs", spnum, "joined", npathsc, "left", npathsleft);  // could use not-joined paths as a guess of which colours to filter as engravings
        jdseqs = jdseqs.concat(ljdseqs); 
    }
    // jdseqs = [ [i1, i2, i3,...] sequence of dlist[ii/2|0], bfore=((ii%2)==1 ]

    // list of paths not included in any cycle
    $("#readingcancel").text("getsingletlist"); 
    var singletslist = GetSingletsList(jdseqs, dlist.length)

    // build the dlist without any holes parallel to rlistb to use for groupings
    var dlist = [ ]; 
    for (var i = 0; i < rlistb.length; i++) 
        dlist.push(rlistb[i].path.attrs.path); 
    $("#readingcancel").text("concat JDgeoseqs"); 
    var jdgeos = [ ]; 
    for (var i = 0; i < jdseqs.length; i++) {
        jdgeos.push(JDgeoseq(jdseqs[i], dlist)); // concatenated sequences of paths forming the boundaries
    }

    // groups of jdsequences forming outercontour, islands, singlets 
    $("#readingcancel").text("FindAreaGroupingsD"); 
    var res = [ ]; 
    var cboundislands = FindAreaGroupingsD(jdgeos); 
    
    $("#readingcancel").text("oriented islands"); 
    for (var j = 0; j < cboundislands.length; j++) {
        var lres = [ ]; 
        var cboundisland = cboundislands[j]; 
        for (var ci = 0; ci < cboundisland.length; ci++) {
            var i = cboundisland[ci]; 
            var jdgeo = jdgeos[i]; 
            var bfore = FindPathOrientation(jdgeo); 
            var jdseq = (((ci == 0) == bfore) ? jdseqs[i] : RevJDseq(jdseqs[i])); 
            lres.push(jdseq); 
        }
        lres.push([ ]); // the slot for the list of singlet paths
        res.push(lres); 
    }
    
    $("#readingcancel").text("singlets to groupings"); 
    for (var i = 0; i < singletslist.length; i++) {
        var ic = singletslist[i]; 
        var dpath = dlist[ic]; 
        var j = SingletsToGroupingsD(dpath, cboundislands, jdgeos); 
        if (j != -1)
            res[j][res[j].length-1].push(ic); 
    }

    console.log("resres", res); 
    return res; 
}

function processimportedSVGnew(rlistb)
{
    var closedist = 3.2; 
    var pathgroupings = ProcessToPathGroupings(rlistb, closedist); // just lists of indexes into rlistb
    $("#readingcancel").text("done ProcessToPathGroupings"); 

    // rebuild this groupings directly from the above indexing sets
    var dlist = [ ]; 
    for (var i = 0; i < rlistb.length; i++) 
        dlist.push(rlistb[i].path.attrs.path); 

    $.each(pathgroupings, function(i, pathgrouping) {
        // form the area object
        var dgroup = [ ]; 
        console.log("jjj", pathgrouping); 
        for (var j = 0; j < pathgrouping.length - 1; j++) {
            dgroup = dgroup.concat(JDgeoseq(pathgrouping[j], dlist)); 
        }
        var pgroup = paper1.path(dgroup); 
        pgroup.attr({stroke:"white", fill:"#0f0", "fill-opacity":"10%"}); 
        
        // form the list of all paths belonging to this area object
        var lpaths = [ pgroup ]; 
        var engpaths = pathgrouping[pathgrouping.length - 1]; 
        for (var i = 0; i < engpaths.length; i++)
            lpaths.push(rlistb[engpaths[i]].path); 
        for (var j = 0; j < pathgrouping.length - 1; j++) {
            for (var i = 0; i < pathgrouping[j].length; i++)
                lpaths.push(rlistb[pathgrouping[j][i]/2|0].path); 
        }
        
        var brotatemode = false; 
        var cx = 0, cy = 0; 
        pgroup.drag(
            function(dx, dy) { 
                var tstr = (brotatemode ? "r"+(dx*0.5)+","+cx+","+cy : "t"+(dx*paper1scale)+","+(dy*paper1scale)); 
                $.each(lpaths, function(i, path) { 
                    path.transform(tstr); 
                }); 
            }, 
            function(x, y, e)  { 
                brotatemode = e.ctrlKey; 
                pathselected = pgroup; 
                var bbox = pgroup.getBBox(); 
                cx = (bbox.x + bbox.x2)/2; 
                cy = (bbox.y + bbox.y2)/2; 
            }, 
            function() { 
                $.each(lpaths, function(i, path) { 
                    path.attr("path", Raphael.mapPath(path.attr("path"), path.matrix)); 
                    path.transform("t0,0") 
                }); 
            }
        ); 
    }); 
}

var Dbpathssinglets, Dareagroups; 
function processimportedSVG(fnum)
{
    // first join paths up
    var rlistb = rlistbyfnum[fnum]; 
    var closedist = 3.2; 

    processimportedSVGnew(rlistb); 
    return; 
    
    // should process these by colour
    var cycseqs = FindClosedPathSequences(rlistb, closedist); // [{bpaths:[], darea, spnum}]
    var bpathssinglets = cycseqs.pop(); 
    var contislandlists = FindAreaGroupings(rlistb, cycseqs); // [[iouter,island1,island2..],...]
    Dbpathssinglets = bpathssinglets; 
    var areagroups = CreateAreaGroupings(rlistb, cycseqs, contislandlists); // [{gcyceseqs,dgroup,allpaths}]
    Dareagroups = areagroups; 
    SingletsToGroupings(areagroups, bpathssinglets); 

    // should be done after things are closed, joined up and associated with their areas
    // move to outer function
    $.each(areagroups, function(i, areagroup) {
        var brotatemode = false; 
        var cx = 0, cy = 0; 

        var pgroup = paper1.path(areagroup.dgroup); 
        pgroup.attr({stroke:"white", fill:"#ff0", "fill-opacity":"10%"}); 
        areagroup.pgroup = pgroup; 

        var lpaths = [ areagroup.pgroup ]; 
        for (var i = 0; i < areagroup.allpaths.length; i++)
            lpaths.push(areagroup.allpaths[i].path); 
        
        areagroup.pgroup.drag(
            function(dx, dy) { 
                var tstr = (brotatemode ? "r"+(dx*0.5)+","+cx+","+cy : "t"+(dx*paper1scale)+","+(dy*paper1scale)); 
                $.each(lpaths, function(i, path) { 
                    path.transform(tstr); 
                }); 
            }, 
            function(x, y, e)  { 
                brotatemode = e.ctrlKey; 
                pathselected = pgroup; 
                var bbox = areagroup.pgroup.getBBox(); 
                cx = (bbox.x + bbox.x2)/2; 
                cy = (bbox.y + bbox.y2)/2; 
            }, 
            function() { 
                $.each(lpaths, function(i, path) { 
                    path.attr("path", Raphael.mapPath(path.attr("path"), path.matrix)); 
                    path.transform("t0,0") 
                }); 
            }
        ); 
    }); 
    
}

function processSingleSVGpath(rlistb, d, cmatrix, stroke)
{
    var dtrans = Raphael.mapPath(d, cmatrix); // Raphael.transformPath(d, raphtranslist.join("")); 
    if (dtrans.length <= 1)
        return; // skip
    if ((stroke == "none") || (stroke === undefined))
        return; // skip

    // this is the place to separate out the paths by M positions
    var path = paper1.path(dtrans); 
    path.attr({stroke:stroke, "stroke-width":2}); 

    var spcol = path.attr("stroke");  
    if (spnums[spcol] == undefined) {
        spnums[spcol] = ++spcount; 
        $("#spnumcols").append($('<span id="spnum'+spcount+'">X</span>').css("background", spcol)); 
    }
    rlist.push(path); 
    rlistb.push({path:path, spnum:spnums[spcol], d:d, cmatrix:cmatrix}); 
}

var Dtxt, Dtsvg; 
function importSVG(txt, fnum)
{
    console.log(txt.length+" bytes"); 
    Dtxt = txt; 
    var tsvg = $($(txt).children()[0]).parent(); // seems not to work directly
    Dtsvg = tsvg; 
    
    var td = $(txt);
    console.log("calc pixscale"); 
    WorkOutPixelScale(txt, td); 
    var dscalebar = "M20,20l"+(100*mmpixwidth)+",0l0,5M20,20l0,"+(100*mmpixheight)+"l5,0"; 
    paper1.path(dscalebar).attr("stroke", "#b66"); 

    bcancelExIm = false; 
    var timeoutcyclems = 10; 
    var pback = {pos:-1, raphtranslist:[""], strokelist:[undefined], cmatrix:Raphael.matrix() };
    var pstack = [ ]; 
    var cstack = [ tsvg ]; 
    var mclassstroke = { }; 
    tsvg.find("style").text().replace(/\.([\w\d\-]+)\s*\{[^\}]*stroke:\s*([^;\s\}]+)/gi, function(a, b, c) { mclassstroke[b] = c; }); 
    var rlistb = rlistbyfnum[fnum]; 
    
    function importSVGpathR() {
        while (cstack.length == pback.pos) 
            pback = pstack.pop(); 
        if (cstack.length == 0) {
            processimportedSVG(fnum); 
            return; 
        }
        var c = cstack.pop(); 
        var tag = c.prop("tagName").toLowerCase(); 
        var raphtranslist = pback.raphtranslist; 
        var cmatrix = pback.cmatrix; 
        if (c.attr("transform")) {
            raphtranslist = raphtranslist.slice(); 
            raphtranslist.push(c.attr("transform").replace(/([mtrs])\w+\s*\(([^\)]*)\)/gi, function(a, b, c) { return b.toLowerCase()+c+(b.match(/s/i) ? ",0,0" : ""); } )); 
            cmatrix = paper1.path().transform(raphtranslist.join("")).matrix; 
        }

        var strokelist = pback.strokelist; 
        var cstroke = c.attr("stroke") || c.css("stroke") || mclassstroke[c.attr("class")]; 
        if (cstroke) {
            strokelist = strokelist.slice(); 
            strokelist.push(cstroke); 
        } else {
            cstroke = strokelist[strokelist.length - 1]; 
        }
        if (tag == "pattern") {
            console.log("skip pattern"); 
        } else if ((tag == "polygon") || (tag == "polygline")) {
            var ppts = c.attr("points").split(/\s+|,/);
            var x0 = ppts.shift(); 
            var y0 = ppts.shift();
            var d = 'M'+x0+','+y0+'L'+ppts.join(' ')+(tag == "polygon" ? "Z" : ""); 
            processSingleSVGpath(rlistb, d, cmatrix, cstroke); 
        } else if (tag == "circle") {
            var cx = parseFloat(c.attr("cx"));
            var cy = parseFloat(c.attr("cy")); 
            var r = parseFloat(c.attr("r")); 
            var d = "M"+(cx-r)+","+cy+"A"+r+","+r+",0,0,1,"+cx+","+(cy-r)+"A"+r+","+r+",0,1,1,"+(cx-r)+","+cy; 
            processSingleSVGpath(rlistb, d, cmatrix, cstroke); 
        } else if (tag == "rect") {
            var x0 = parseFloat(c.attr("x"));
            var y0 = parseFloat(c.attr("y")); 
            var x1 = x0 + parseFloat(c.attr("width")); 
            var y1 = y0 + parseFloat(c.attr("height")); 
            var d = "M"+x0+","+y0+"L"+x0+","+y1+" "+x1+","+y1+" "+x1+","+y0+"Z"; 
            processSingleSVGpath(rlistb, d, cmatrix, cstroke); 
        } else if (tag == "path") {
            processSingleSVGpath(rlistb, c.attr("d"), cmatrix, cstroke); 
        } else {
            pstack.push(pback); 
            pback = { pos:cstack.length, raphtranslist:raphtranslist, strokelist:strokelist, cmatrix:cmatrix }; 
            var cs = c.children(); 
            for (var i = cs.length - 1; i >= 0; i--) 
                cstack.push($(cs[i]));   // in reverse order for the stack
        }
        if (!bcancelExIm) {
            $("#readingcancel").text(rlist.length+"/"+cstack.length); 
            setTimeout(importSVGpathR, timeoutcyclems); 
        } else {
            $("#readingcancel").text("CANCELLED"); 
        }
    }
    importSVGpathR(); 
}

// handle EPS files using call out to server to execute pstoedit 
function importSVGfiles(files)
{
    $.each(files, function(i, f) { 
        if (!f.type.match('image/svg\\+xml')) {
            alert(f.name+" not SVG file: "+f.type); 
            return;
        }
        var fnum = filenamelist.length; 
        filenamelist.push(f.name); 
        rlistbyfnum.push([ ]); 
        var reader = new FileReader();
        reader.onload = (function(e) { importSVG(reader.result, fnum); }); 
        reader.readAsText(f); 
    }); 
}


var rect1;
function setup()
{
    $("#exportSVG").click(exportSVG); 
    $("#exportPLT").click(exportPLT); 
    $("#movecollide").click(MoveCollide); 
    $("#files").change(function(e) { importSVGfiles(e.target.files); });  

    $("#paper1").on('dragover', function(e) {
        e.stopPropagation(); e.preventDefault(); 
    }).on('dragenter', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).addClass("dropfileselected"); 
    }).on('dragleave', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).removeClass("dropfileselected"); 
    }).on('drop', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).removeClass("dropfileselected"); 
        importSVGfiles(e.originalEvent.dataTransfer.files); 
    }); 

    $("#readingcancel").click(function() { bcancelExIm = true; }); 
    $("#scaledouble").click(function() { $("#scaledouble").text($("#scaledouble").text() == "*2" ? "/2" : "*2"); }); 
    $("#scale").click(function() { 
        paper1scale *= ($("#scaledouble").text() == "*2" ? 2 : 0.5); 
        paper1.setViewBox(0, 0, paper1.width*paper1scale, paper1.height*paper1scale); 
        $("#scale").text(paper1scale); 
    }); 
    $("#scaledouble, #scale").mousedown(function(e) { e.preventDefault(); }); // stop selection on double-click
    $("#scale").text(paper1scale); 
    
    // setup the raphael paper and bits
    paper1 = Raphael("paper1", 1300, 800);
    rect1 = paper1.path("M20,30 L100,122 L40, 100 Z").attr({fill: "orange"});
    rect2 = paper1.path("M220,30 L300,122 L290, 100 Z").attr({fill: "blue"});
    var data = $("#paper1 svg").attr("id", "svg1"); 
    
    // scratch object
    var brotatemode = false; 
    rect1.drag(function(dx, dy, x, y, e) { var sv = (brotatemode ? "r"+dx : "t"+dx+","+dy); console.log(sv); rect1.transform(sv); }, 
         function(x, y, e)  { brotatemode = e.ctrlKey }, 
         function(e) { rect1.attr("path", Raphael.mapPath(rect1.attr("path"), rect1.matrix)); rect1.transform("t0,0") }); 
    rect1.onDragOver(function(e) { console.log(e); }); 
    pathselected = rect1; 
}

$(document).ready(setup);   // function to call only *after* page has finished loading

</script>

<style>
#err { color:red }
.dropfileselected { background: #ffa }
#readingcancel:hover { background: red; cursor: pointer }
#scale:hover, #scaledouble:hover { background:yellow; cursor:pointer }
#spnumcols:hover { cursor:pointer; }
#spnumcols span { border: thin black solid }
#spnumcols span:hover { border-color:white }

</style>

</head>
<body bgcolor="#e8e8e8">
  
<div>
    <input type="button" value="exportSVG" id="exportSVG"/>
    <input type="button" value="exportPLT" id="exportPLT"/>
    <input type="button" value="MOVE!" id="movecollide">
    <span id="scale">1</span><span id="scaledouble">*2</span>
    <span id="spnumcols"></span>
    <input type="file" id="files" name="files[]" multiple />
    <span id="pixscale">pix-scaleX(mm):<span id="pixscaleX"></span>  pix-scaleY(mm):<span id="pixscaleY"></span></span>
    <span id="readingcancel">0/0</span>
</div>
<div style="border: thin black solid" id="paper1"></div>
  
<p>Code is <a href="https://github.com/goatchurchprime/doesliverpool.github.io/">here</a></p>

<p>Work to do:
* find bug in snowflake
* create objects/classes to 


*file select dropdowns that refer to local banks of colours/scales/unified line calls that may be different and can be rerun
*EPS conversion using pstoedit on the twisted server
*select stock shape and type of material which is always underneath (allow for multiple sheets)
*drop-down of the sizes of stock (ply) which gets plotted in brown as the area, and material (which generates the lookup for the feeds and speeds)
*join paths to make closed contours - specify which colour is the outer one
*use colours or picking to specify the engraving curves
*associate the etching curves with those cutting curves we are in by group
*estimates of time to cut, which can be used to check if order of cut improving.  do cuts after each etch so abort still have working results
*moving around by recording the transforms so can rerender and render the associated etching curves
*slide things to the right onto the area if off the sides
*begin relay packing within area and clearance bits
*export that ply sheet and remove everything on it
*allow this file to serve from BB, which should be on the net somewhere accessible to the Laser Machine
*colour bits by stock material (colour, thickness, type)
*twisted banks and serves out components for the cutter, previews what's being calculated elsewhere.  
*layouts are saved as json objects and reimported, merged, etc.
</p>

</body>
</html>
