<!DOCTYPE html>
<html>
<head>
<script src="jquery-2.1.4.min.js"></script>    
<script type="text/javascript" src="raphael.js"></script>    
<meta charset="utf-8">
<title>Experimental SVG lattice hinge generator</title>
<script>

function exportSVG()
{
    var xs = new XMLSerializer();
    var data = document.getElementById("svg1");
    var details = xs.serializeToString(data);
    $("#text_output").val(details);
}

var bcancelExIm = false; 
function exportPLT()
{
    var lplt = [ "IN;\n", "WU0;\n" ]; 
    var samplerateunit = 0.9; 
    var fac = 40/mmpixwidth; // PLT file operates at 40units per pixel
    var ytop = 10000; 
    var spnums = { }, spcount = 1; 
    var i = 0; 
    bcancelExIm = false; 
    $("#readingcancel").text("exportPLT"); 
    function exportPLTpathR() {
        console.log(i); 
        console.log(rlist); 
        var path = rlist[i]; 
        console.log(path); 
        var pl = path.getTotalLength(); 
        if (pl != 0.0) {
            var nsamples = Math.ceil(pl/samplerateunit); 
            if (spnums[path.attr("stroke")] == undefined)
                spnums[path.attr("stroke")] = spcount++; 
            var spnum = spnums[path.attr("stroke")]; 
            lplt.push("SP"+spnum+";\n"); 
            lplt.push("LT;\n"); 
            for (var j = 0; j <= nsamples; j++) {
                var p = path.getPointAtLength(pl*(j/nsamples)); 
                lplt.push((j == 0 ? "PU" : "PD")+(p.x*fac).toFixed(3)+" "+(ytop-p.y*fac).toFixed(3)+"\n"); 
            }
        }
        if (bcancelExIm) {
            return; 
        } else if (++i < rlist.length) {
            setTimeout(exportPLTpathR, 1); 
        } else {
            lplt.push("SP0;\n"); 
            var a = document.createElement('a');
            var blob = new Blob([lplt.join("\n")], {'type':"text/plain"});
            a.href = window.URL.createObjectURL(blob);
            a.download = "test.plt";
            a.click();
        }
        $("#readingcancel").text(i+"/"+rlist.length); 
    };
    exportPLTpathR(); 
    //$("#text_output").val(lplt.join("\n"));
}

var mmpixwidth, mmpixheight; // to be used to scale back to output SVG
function WorkOutPixelScale(txt, td) 
{
    var tsvg = $(td.children()[0]).parent(); // seems not to work directly
    var sheight = tsvg.attr("height"); 
    var swidth = tsvg.attr("width"); 
    var viewBox = []; // (seemingly unable to lift the viewBox as an attribute)
    txt.replace(/viewBox="(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)/g, 
        function(a, x, y, w, h) { 
            viewBox.push(parseFloat(x), parseFloat(y), parseFloat(w), parseFloat(h)); 
    }); 
    console.log("facts:" + sheight+"  "+swidth + "  "+viewBox); 
    var mmheight = parseFloat(sheight); 
    var mmwidth = parseFloat(swidth); 
    mmpixwidth = viewBox[2]/mmwidth; 
    mmpixheight = viewBox[3]/mmheight; 
    $("#pixscaleX").text(mmpixwidth.toFixed(3)); 
    $("#pixscaleY").text(mmpixheight.toFixed(3)); 
}

function TestCollision(dx, dy) 
{
    for (var i = 0; i < opts.length; i++) {
        var x = opts[i][0] + dx; 
        var y = opts[i][1] + dy; 
        if (y >= paper1.height*paper1scale)
            return false; 
        for (var j = 0; j < rlist.length; j++) {
            if (rlist[j] == pathselected)
                continue; 
            if (rlist[j].isPointInside(x, y))
                return false; 
        }
    }
    return true; 
}

var paper1 = null; 
var paper1scale = 1; 
var rlist = [ ]; 
var pathselected = null; 
var opts; 
var collidestepout = 10, collidestepover = 10; 
var ylo, yhi; 
var perprods; 
function CollideBinary() 
{
    // paper1.getElementsByPoint(x, y); 
    var ymid = (ylo + yhi)/2; 
    if (TestCollision(0, ymid)) {
        ylo = ymid; 
        pathselected.transform("t0,"+ylo); 
    } else {
        yhi = ymid; 
    }
    if (yhi - ylo <= collidestepout + 1) {
        pathselected.attr("path", Raphael.mapPath(pathselected.attr("path"), pathselected.matrix)); 
        pathselected.transform("t0,0"); 
        perprods.remove(); 
    } else {
        setTimeout(CollideBinary, 5); 
    }
}

/* refer to: 
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
*/

function MoveCollide()
{
    path = pathselected; 
    var pl = path.getTotalLength(); 
    console.log(pl); 
    var ds = [ ]; 
    opts = [ ]; 
    for (var i = 0; i < pl; i += collidestepover) {
        var pal = path.getPointAtLength(i); 
        var angnorm = Raphael.rad(pal.alpha+90); 
        var sa = Math.sin(angnorm); 
        var ca = Math.cos(angnorm); 
        var d = collidestepout; 
        if (path.isPointInside(pal.x+ca*d, pal.y+sa*d)) { d = -d }; 
        ds.push("M", pal.x, ",", pal.y, "l", ca*d, ",", sa*d); 
        opts.push([pal.x+ca*d, pal.y+sa*d]); 
    }
    
    perprods = paper1.path(ds.join("")); 
    ylo = 0; 
    yhi = 400; 
    setTimeout(CollideBinary, 5); 
}

function importSVG(txt)
{
    console.log(txt.length+" bytes"); 
    var td = $(txt);
    console.log("calc pixscale"); 
    WorkOutPixelScale(txt, td); 
    var dscalebar = "M20,20l"+(100*mmpixwidth)+",0l0,5M20,20l0,"+(100*mmpixheight)+"l5,0"; 
    paper1.path(dscalebar).attr("stroke", "#b66"); 
    
    var timeoutcyclems = 10; 
    console.log("find paths"); 
    var tdpaths = td.find("path");   // this stalls on really big files
    var i = 0; 
    bcancelExIm = false; 
    function importSVGpathR() {
        var vd = $(tdpaths[i]); 
        var d = vd.attr("d"); 
        if (true || d.search(/Z$/gi) != -1) {
            var transforms = [ vd.attr("transform") ]; 
            vd.parents().each(function(j, p) { transforms.push($(p).attr("transform")); }); 
            var stransforms = [ ]; 
            $.each(transforms.reverse(), function(j, t) {  if (t)  stransforms.push(t.replace(/([mtrs])\w+\s*\(([^\)]*)\)/gi, function(a, b, c) { return b.toLowerCase()+c+(b.match(/s/i) ? ",0,0" : ""); } )) }); 
            console.log(stransforms.join("")); 
            d = Raphael.transformPath(d, stransforms.join("")); 
            var path = paper1.path(d);
            path.attr({stroke:vd.css("stroke"), "stroke-width":2, fill:"#00f", "fill-opacity":"10%"}); 
            var brotatemode = false; 
            path.drag(
                function(dx, dy) { path.transform(brotatemode ? "r"+(dx*0.25) : "t"+(dx*paper1scale)+","+(dy*paper1scale)); }, 
                function(x, y, e)  { brotatemode = e.ctrlKey; pathselected = path; }, 
                function() { path.attr("path", Raphael.mapPath(path.attr("path"), path.matrix)); path.transform("t0,0") }
            ); 
            rlist.push(path); 
        }
        if ((++i < tdpaths.length) && !bcancelExIm)
            setTimeout(importSVGpathR, timeoutcyclems); 
        $("#readingcancel").text(i+"/"+tdpaths.length); 
    };
    importSVGpathR(); 
}

var Df; 
function importSVGfiles(files)
{
    $.each(files, function(i, f) { 
        Df = f; 
        if (!f.type.match('image/svg\\+xml')) {
            alert(f.name+" not SVG file: "+f.type); 
            return;
        }
        var reader = new FileReader();
        reader.onload = (function(e) { importSVG(reader.result); }); 
        reader.readAsText(f);
    }); 
}


var rect1;
function setup()
{
    $("#export").click(exportSVG); 
    $("#exportPLT").click(exportPLT); 
    $("#movecollide").click(MoveCollide); 
    $("#import").click(function(e) { importSVG($("#text_output").val()); }); 
    $("#files").change(function(e) { importSVGfiles(e.target.files); });  
    $("#files").on('dragover', function(e) {
        e.stopPropagation(); e.preventDefault(); 
    }).on('dragenter', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).addClass("dropfileselected"); 
    }).on('dragleave', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).removeClass("dropfileselected"); 
    }).on('drop', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        importSVGfiles(e.originalEvent.dataTransfer.files); 
    }); 
    $("#readingcancel").click(function() { bcancelExIm = true; }); 
    $("#scaledouble").click(function() { $("#scaledouble").text($("#scaledouble").text() == "*2" ? "/2" : "*2"); }); 
    $("#scale").click(function() { 
        paper1scale *= ($("#scaledouble").text() == "*2" ? 2 : 0.5); 
        paper1.setViewBox(0, 0, paper1.width*paper1scale, paper1.height*paper1scale); 
        $("#scale").text(paper1scale); 
    }); 
    $("#scaledouble, #scale").mousedown(function(e) { e.preventDefault(); }); // stop selection on double-click
    $("#scale").text(paper1scale); 
    
    
    // setup the raphael paper
    paper1 = Raphael("paper1", 1300, 800);
    rect1 = paper1.path("M20,30 L100,122 L40, 100 Z").attr({fill: "orange"});
    rect2 = paper1.path("M220,30 L300,122 L290, 100 Z").attr({fill: "blue"});
    var data = $("#paper1 svg").attr("id", "svg1"); 
    
    // scratch object
    var brotatemode = false; 
    rect1.drag(function(dx, dy, x, y, e) { var sv = (brotatemode ? "r"+dx : "t"+dx+","+dy); console.log(sv); rect1.transform(sv); }, 
         function(x, y, e)  { brotatemode = e.ctrlKey }, 
         function(e) { rect1.attr("path", Raphael.mapPath(rect1.attr("path"), rect1.matrix)); rect1.transform("t0,0") }); 
    rect1.onDragOver(function(e) { console.log(e); }); 
    pathselected = rect1; 
}

$(document).ready(setup);   // function to call only *after* page has finished loading

</script>

<style>
input[type="text"] { width:6em }
#err { color:red }
#text_output { height: 1em; width: 250px }
.thing { background: red }
.dropfileselected { background: yellow }
#readingcancel:hover { background: red; cursor: pointer }
#scale:hover, #scaledouble:hover { background:yellow; cursor:pointer }

</style>

</head>
<body bgcolor="#e8e8e8">
  
<div>
    <input type="button" value="export" id="export"/>
    <input type="button" value="exportPLT" id="exportPLT"/>
    <input type="button" value="MOVE!" id="movecollide">
    <span id="scale">1</span><span id="scaledouble">*2</span>
    <input type="button" value="import" id="import"/>
    <textarea id="text_output"></textarea>
    <input type="file" id="files" name="files[]" multiple />
    <span id="pixscale">pix-scaleX(mm):<span id="pixscaleX"></span>  pix-scaleY(mm):<span id="pixscaleY"></span></span>
    <span id="readingcancel">0/0</span>
</div>
<div style="border: thin black solid" id="paper1"></div>
  
<p>Code is <a href="https://github.com/goatchurchprime/doesliverpool.github.io/">here</a></p>

<p>Work to do:
*change td.find("path") so it iterates through children rather than global slow find function and keeps stack of transforms
*interface table colours so can select which is external one and group all internal curves with it
</p>

</body>
</html>
