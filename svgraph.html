<!DOCTYPE html>
<html>
<head>
<script src="jquery-2.1.4.min.js"></script>    
<script type="text/javascript" src="raphael.js"></script>    
<meta charset="utf-8">
<title>Experimental SVG lattice hinge generator</title>
<script>

function exportSVG()
{
    var xs = new XMLSerializer();
    var data = document.getElementById("svg1");
    var details = xs.serializeToString(data);
    $("#text_output").val(details);
}

function exportPLT()
{
    var lplt = [ "IN;", "WU0;" ]; 
    var samplerateunit = 0.9; 
    var fac = 40/mmpixwidth; // PLT file operates at 40units per pixel
    var ytop = 10000; 
    var spnums = { }, spcount = 1; 
    $.each(rlist, function(i, path) {
        var pl = path.getTotalLength(); 
        if (pl != 0.0) {
            var nsamples = Math.ceil(pl/samplerateunit); 
            if (spnums[path.attr("stroke")] == undefined)
                spnums[path.attr("stroke")] = spcount++; 
            var spnum = spnums[path.attr("stroke")]; 
            lplt.push("SP"+spnum+";"); 
            lplt.push("LT;"); 
            for (var i = 0; i <= nsamples; i++) {
                var p = path.getPointAtLength(pl*(i/nsamples)); 
                lplt.push((i == 0 ? "PU" : "PD")+(p.x*fac).toFixed(3)+" "+(ytop-p.y*fac).toFixed(3)); 
            }
        }
    }); 
    lplt.push("SP0;"); 
    
    /*var xd = 240;  // make the test wedge
    var yd = Math.sin(Raphael.rad(2.5))*xd; 
    function cc(x, y) { return (x*fac).toFixed(3)+","+(ytop-y*fac).toFixed(3); }
    lplt.push("PU;SP4;PA"+cc(180,110)+";PD"+cc(180,110)+","+cc(180,90)); 
    lplt.push("PU;SP4;PA"+cc(100,100)+";PD"+cc(100,100)+","+cc(100+xd,100+yd)+","+cc(100+xd,100-yd)+","+cc(100,100)); */
    
    $("#text_output").val(lplt.join("\n"));
}

var mmpixwidth, mmpixheight; // to be used to scale back to output SVG
function WorkOutPixelScale(txt, td) 
{
    var tsvg = $(td.children()[0]).parent(); // seems not to work directly
    var sheight = tsvg.attr("height"); 
    var swidth = tsvg.attr("width"); 
    var viewBox = []; // (seemingly unable to lift the viewBox as an attribute)
    txt.replace(/viewBox="(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)\s+(-?\d*\.?\d*(?:e[\-+]?\d+)?)/g, 
        function(a, x, y, w, h) { 
            viewBox.push(parseFloat(x), parseFloat(y), parseFloat(w), parseFloat(h)); 
    }); 
    console.log("facts:" + sheight+"  "+swidth + "  "+viewBox); 
    var mmheight = parseFloat(sheight); 
    var mmwidth = parseFloat(sheight); 
    mmpixwidth = viewBox[2]/mmwidth; 
    mmpixheight = viewBox[3]/mmheight; 
    $("#pixscaleX").text(mmpixwidth.toFixed(3)); 
    $("#pixscaleY").text(mmpixheight.toFixed(3)); 
}

function TestCollision(dx, dy) 
{
    for (var i = 0; i < opts.length; i++) {
        var x = opts[i][0] + dx; 
        var y = opts[i][1] + dy; 
        if (y >= paper1.height)
            return false; 
        for (var j = 0; j < rlist.length; j++) {
            if (rlist[j] == pathselected)
                continue; 
            if (rlist[j].isPointInside(x, y))
                return false; 
        }
    }
    return true; 
}

var paper1 = null; 
var rlist = [ ]; 
var pathselected = null; 
var opts; 
var collidestepout = 10, collidestepover = 10; 
var ylo, yhi; 
var perprods; 
function CollideBinary() 
{
    // paper1.getElementsByPoint(x, y); 
    var ymid = (ylo + yhi)/2; 
    if (TestCollision(0, ymid)) {
        ylo = ymid; 
        pathselected.transform("t0,"+ylo); 
    } else {
        yhi = ymid; 
    }
    if (yhi - ylo <= collidestepout + 1) {
        pathselected.attr("path", Raphael.mapPath(pathselected.attr("path"), pathselected.matrix)); 
        pathselected.transform("t0,0"); 
        perprods.remove(); 
    } else {
        setTimeout(CollideBinary, 5); 
    }
}

/* refer to: 
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
*/

function MoveCollide()
{
    path = pathselected; 
    var pl = path.getTotalLength(); 
    console.log(pl); 
    var ds = [ ]; 
    opts = [ ]; 
    for (var i = 0; i < pl; i += collidestepover) {
        var pal = path.getPointAtLength(i); 
        var angnorm = Raphael.rad(pal.alpha+90); 
        var sa = Math.sin(angnorm); 
        var ca = Math.cos(angnorm); 
        var d = collidestepout; 
        if (path.isPointInside(pal.x+ca*d, pal.y+sa*d)) { d = -d }; 
        ds.push("M", pal.x, ",", pal.y, "l", ca*d, ",", sa*d); 
        opts.push([pal.x+ca*d, pal.y+sa*d]); 
    }
    
    perprods = paper1.path(ds.join("")); 
    ylo = 0; 
    yhi = 400; 
    setTimeout(CollideBinary, 5); 
}

function importSVG(txt)
{
    var td = $(txt);
    WorkOutPixelScale(txt, td); 
    var dscalebar = "M20,20l"+(100/mmpixwidth)+",0l0,5M20,20l0,"+(100/mmpixheight)+"l5,0"; 
    paper1.path(dscalebar).attr("stroke", "#b66"); 

    // do port the paths over to raphaeljs
    td.find("path").each(function(i, v) { 
        var vd = $(v); 
        var d = vd.attr("d"); 
        if (true || d.search(/Z$/gi) != -1) {
            var transforms = [ vd.attr("transform") ]; 
            vd.parents().each(function(j, p) { transforms.push($(p).attr("transform")); }); 
            var stransforms = [ ]; 
            $.each(transforms.reverse(), function(j, t) {  if (t)  stransforms.push(t.replace(/([mtrs])\w+\s*\(([^\)]*)\)/gi, function(a, b, c) { return b.toLowerCase()+c+(b.match(/s/i) ? ",0,0" : ""); } )) }); 
            console.log(stransforms.join("")); 
            d = Raphael.transformPath(d, stransforms.join("")); 
            var path = paper1.path(d);
            path.attr({stroke:vd.css("stroke"), "stroke-width":2, fill:"#00f", "fill-opacity":"10%"}); 
            var brotatemode = false; 
            path.drag(
                function(dx, dy) { path.transform(brotatemode ? "r"+(dx*0.25) : "t"+dx+","+dy); }, 
                function(x, y, e)  { brotatemode = e.ctrlKey; pathselected = path; }, 
                function() { path.attr("path", Raphael.mapPath(path.attr("path"), path.matrix)); path.transform("t0,0") }
            ); 
            rlist.push(path); 
        }
    }); 
}

var Df; 
function importSVGfiles(files)
{
    $.each(files, function(i, f) { 
        Df = f; 
        if (!f.type.match('image/svg\\+xml')) {
            alert(f.name+" not SVG file: "+f.type); 
            return;
        }
        var reader = new FileReader();
        reader.onload = (function(e) { importSVG(reader.result); }); 
        reader.readAsText(f);
    }); 
}


var rect1;
function setup()
{
    $("#export").click(exportSVG); 
    $("#exportPLT").click(exportPLT); 
    $("#movecollide").click(MoveCollide); 
    $("#import").click(function(e) { importSVG($("#text_output").val()); }); 
    $("#files").change(function(e) { importSVGfiles(e.target.files); });  
    $("#files").on('dragover', function(e) {
        e.stopPropagation(); e.preventDefault(); 
    }).on('dragenter', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).addClass("dropfileselected"); 
    }).on('dragleave', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        $(this).removeClass("dropfileselected"); 
    }).on('drop', function(e) {
        e.stopPropagation(); e.preventDefault(); 
        importSVGfiles(e.originalEvent.dataTransfer.files); 
    }); 

   
    // setup the raphael paper
    paper1 = Raphael("paper1", 1300, 800);
    rect1 = paper1.path("M20,30 L100,122 L40, 100 Z").attr({fill: "orange"});
    rect2 = paper1.path("M220,30 L300,122 L290, 100 Z").attr({fill: "blue"});
    var data = $("#paper1 svg").attr("id", "svg1"); 
    
    // scratch object
    var brotatemode = false; 
    rect1.drag(function(dx, dy, x, y, e) { var sv = (brotatemode ? "r"+dx : "t"+dx+","+dy); console.log(sv); rect1.transform(sv); }, 
         function(x, y, e)  { brotatemode = e.ctrlKey }, 
         function(e) { rect1.attr("path", Raphael.mapPath(rect1.attr("path"), rect1.matrix)); rect1.transform("t0,0") }); 
    rect1.onDragOver(function(e) { console.log(e); }); 
    pathselected = rect1; 
}

$(document).ready(setup);   // function to call only *after* page has finished loading

</script>

<style>
input[type="text"] { width:6em }
#err { color:red }
#text_output { height: 1em; width: 250px }
.thing { background: red }
.dropfileselected { background: yellow }
</style>

</head>
<body bgcolor="#e8e8e8">
  
<div>
    <input type="button" value="export" id="export"/>
    <input type="button" value="exportPLT" id="exportPLT"/>
    <input type="button" value="MOVE!" id="movecollide">
    <input type="button" value="import" id="import"/>
    <textarea id="text_output"></textarea>
    <input type="file" id="files" name="files[]" multiple />
    <span id="pixscale">pix-scaleX(mm):<span id="pixscaleX"></span>  pix-scaleY(mm):<span id="pixscaleY"></span></span>
</div>
<div style="border: thin black solid" id="paper1"></div>
  
<p>Code is <a href="https://github.com/goatchurchprime/doesliverpool.github.io/">here</a></p>

<p>Work to do:
Can we extract a workable SVG file as output that goes into the laser cutter?
Then easier to add transforms and rotations to the absolute set of parts
Spare parts on the side.
(Ignore for now grouping and etching cases)
Drag pieces across to the laser material base material rectangle
Packing of shapes, want to do this with Python call-back or within javascript code?
Also re-ordering of cuts and starting points for efficiency
offset shapes too in python (takes any set of contours)
Add parts to cut into a database online, listing materials etc, name of person, drop them in.  
Each in own mini SVG window like icon.  Maybe a X10, counts down to zero.
Select size of ply and start clicking on elements to bring in.
Pack in by hand initially, but automatic placement close in, like playing tetris.
Can reject shapes that don't fit to the list.
DXF/SVG produced for the cutting driver
</p>

</body>
</html>
